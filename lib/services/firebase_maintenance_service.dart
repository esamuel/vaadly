import 'package:cloud_firestore/cloud_firestore.dart';
import '../core/models/maintenance_request.dart';

class FirebaseMaintenanceService {
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  
  // Stream maintenance requests for a building
  static Stream<List<MaintenanceRequest>> streamMaintenanceRequests(String buildingId) {
    print('üîç FirebaseMaintenanceService: Starting stream for building: $buildingId');
    print('üîç FirebaseMaintenanceService: Query path: buildings/$buildingId/maintenance_requests');

    return _firestore
        .collection('buildings')
        .doc(buildingId)
        .collection('maintenance_requests')
        // Temporarily remove orderBy to avoid index issues
        // .orderBy('reportedAt', descending: true)
        .snapshots()
        .map((snap) {
          print('üîç FirebaseMaintenanceService: Received ${snap.docs.length} documents from stream');
          if (snap.docs.isEmpty) {
            print('üîç FirebaseMaintenanceService: No documents found in collection');
          }
          final requests = snap.docs.map((doc) {
            print('üîç Document ID: ${doc.id}');
            print('üîç Document data: ${doc.data()}');
            try {
              return MaintenanceRequest.fromMap({...doc.data(), 'id': doc.id});
            } catch (e) {
              print('‚ùå Error parsing document ${doc.id}: $e');
              rethrow;
            }
          }).toList();
          print('üîç FirebaseMaintenanceService: Successfully parsed ${requests.length} requests');
          return requests;
        });
  }

  static Future<bool> putOnHold(String buildingId, String requestId) async {
    try {
      await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .doc(requestId)
          .update({
        'status': MaintenanceStatus.onHold.toString().split('.').last,
        'updatedAt': FieldValue.serverTimestamp(),
      });

      print('‚úÖ Request put on hold');
      return true;
    } catch (e) {
      print('‚ùå Error putting request on hold: $e');
      return false;
    }
  }

  static Future<bool> rejectRequest(String buildingId, String requestId, String reason) async {
    try {
      await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .doc(requestId)
          .update({
        'status': MaintenanceStatus.rejected.toString().split('.').last,
        'rejectionReason': reason,
        'updatedAt': FieldValue.serverTimestamp(),
      });

      print('‚úÖ Request rejected');
      return true;
    } catch (e) {
      print('‚ùå Error rejecting request: $e');
      return false;
    }
  }

  // Get all maintenance requests for a building
  static Future<List<MaintenanceRequest>> getMaintenanceRequests(String buildingId) async {
    try {
      final snapshot = await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .orderBy('reportedAt', descending: true)
          .get();
      
      return snapshot.docs.map((doc) {
        final data = doc.data();
        return MaintenanceRequest.fromMap({...data, 'id': doc.id});
      }).toList();
    } catch (e) {
      print('‚ùå Error getting maintenance requests: $e');
      return [];
    }
  }

  // Add a maintenance request
  static Future<String?> addMaintenanceRequest(String buildingId, MaintenanceRequest request) async {
    try {
      final data = request.toMap();

      // Convert DateTime strings to Firestore Timestamps for better compatibility
      final now = FieldValue.serverTimestamp();
      data['createdAt'] = now;
      data['updatedAt'] = now;
      data['reportedAt'] = Timestamp.fromDate(request.reportedAt);
      if (request.assignedAt != null) data['assignedAt'] = Timestamp.fromDate(request.assignedAt!);
      if (request.startedAt != null) data['startedAt'] = Timestamp.fromDate(request.startedAt!);
      if (request.completedAt != null) data['completedAt'] = Timestamp.fromDate(request.completedAt!);
      if (request.cancelledAt != null) data['cancelledAt'] = Timestamp.fromDate(request.cancelledAt!);

      final docRef = await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .add(data);

      print('‚úÖ Maintenance request added with ID: ${docRef.id}');
      return docRef.id;
    } catch (e) {
      print('‚ùå Error adding maintenance request: $e');
      return null;
    }
  }

  // Update a maintenance request
  static Future<bool> updateMaintenanceRequest(String buildingId, String requestId, MaintenanceRequest request) async {
    try {
      final data = request.toMap();

      // Convert DateTime strings to Firestore Timestamps
      data['updatedAt'] = FieldValue.serverTimestamp();
      data['reportedAt'] = Timestamp.fromDate(request.reportedAt);
      if (request.assignedAt != null) data['assignedAt'] = Timestamp.fromDate(request.assignedAt!);
      if (request.startedAt != null) data['startedAt'] = Timestamp.fromDate(request.startedAt!);
      if (request.completedAt != null) data['completedAt'] = Timestamp.fromDate(request.completedAt!);
      if (request.cancelledAt != null) data['cancelledAt'] = Timestamp.fromDate(request.cancelledAt!);
      data['createdAt'] = Timestamp.fromDate(request.createdAt);

      await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .doc(requestId)
          .update(data);

      print('‚úÖ Maintenance request updated');
      return true;
    } catch (e) {
      print('‚ùå Error updating maintenance request: $e');
      return false;
    }
  }

  // Delete a maintenance request
  static Future<bool> deleteMaintenanceRequest(String buildingId, String requestId) async {
    try {
      await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .doc(requestId)
          .delete();
      
      print('‚úÖ Maintenance request deleted');
      return true;
    } catch (e) {
      print('‚ùå Error deleting maintenance request: $e');
      return false;
    }
  }

  // Status update methods
  static Future<bool> assignToVendor(String buildingId, String requestId, String vendorId, String vendorName) async {
    try {
      await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .doc(requestId)
          .update({
        'status': MaintenanceStatus.assigned.toString().split('.').last,
        'assignedVendorId': vendorId,
        'assignedVendorName': vendorName,
        'assignedAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      print('‚úÖ Request assigned to vendor');
      return true;
    } catch (e) {
      print('‚ùå Error assigning to vendor: $e');
      return false;
    }
  }

  static Future<bool> startWork(String buildingId, String requestId) async {
    try {
      await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .doc(requestId)
          .update({
        'status': MaintenanceStatus.inProgress.toString().split('.').last,
        'startedAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      print('‚úÖ Work started');
      return true;
    } catch (e) {
      print('‚ùå Error starting work: $e');
      return false;
    }
  }

  static Future<bool> completeWork(String buildingId, String requestId, String actualCost) async {
    try {
      await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .doc(requestId)
          .update({
        'status': MaintenanceStatus.completed.toString().split('.').last,
        'completedAt': FieldValue.serverTimestamp(),
        'actualCost': actualCost,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      print('‚úÖ Work completed');
      return true;
    } catch (e) {
      print('‚ùå Error completing work: $e');
      return false;
    }
  }

  static Future<bool> cancelRequest(String buildingId, String requestId, String reason) async {
    try {
      await _firestore
          .collection('buildings')
          .doc(buildingId)
          .collection('maintenance_requests')
          .doc(requestId)
          .update({
        'status': MaintenanceStatus.cancelled.toString().split('.').last,
        'cancelledAt': FieldValue.serverTimestamp(),
        'cancellationReason': reason,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      print('‚úÖ Request cancelled');
      return true;
    } catch (e) {
      print('‚ùå Error cancelling request: $e');
      return false;
    }
  }

  // Get maintenance statistics for a building
  static Future<Map<String, dynamic>> getMaintenanceStatistics(String buildingId) async {
    try {
      final requests = await getMaintenanceRequests(buildingId);
      
      final totalRequests = requests.length;
      final pendingRequests = requests.where((r) => r.status == MaintenanceStatus.pending).length;
      final inProgressRequests = requests.where((r) => r.status == MaintenanceStatus.inProgress).length;
      final completedRequests = requests.where((r) => r.status == MaintenanceStatus.completed).length;
      final urgentRequests = requests.where((r) => r.priority == MaintenancePriority.urgent).length;
      final overdueRequests = requests.where((r) => r.isOverdue).length;
      
      // Category breakdown
      final categoryBreakdown = <String, int>{};
      for (final request in requests) {
        final category = request.categoryDisplay;
        categoryBreakdown[category] = (categoryBreakdown[category] ?? 0) + 1;
      }
      
      // Priority breakdown
      final priorityBreakdown = <String, int>{};
      for (final request in requests) {
        final priority = request.priorityDisplay;
        priorityBreakdown[priority] = (priorityBreakdown[priority] ?? 0) + 1;
      }
      
      return {
        'total': totalRequests,
        'pending': pendingRequests,
        'inProgress': inProgressRequests,
        'completed': completedRequests,
        'urgent': urgentRequests,
        'overdue': overdueRequests,
        'categoryBreakdown': categoryBreakdown,
        'priorityBreakdown': priorityBreakdown,
        'completionRate': totalRequests > 0 ? (completedRequests / totalRequests * 100).toStringAsFixed(1) : '0.0',
      };
    } catch (e) {
      print('‚ùå Error getting maintenance statistics: $e');
      return {
        'total': 0,
        'pending': 0,
        'inProgress': 0,
        'completed': 0,
        'urgent': 0,
        'overdue': 0,
        'categoryBreakdown': <String, int>{},
        'priorityBreakdown': <String, int>{},
        'completionRate': '0.0',
      };
    }
  }

  // Initialize sample maintenance requests for a building
  static Future<void> initializeSampleMaintenanceRequests(String buildingId) async {
    try {
      // Check if requests already exist
      final existingRequests = await getMaintenanceRequests(buildingId);
      if (existingRequests.isNotEmpty) {
        print('‚úÖ Sample maintenance requests already exist for building $buildingId');
        return;
      }

      final sampleRequests = _generateSampleMaintenanceRequests(buildingId);
      
      for (final request in sampleRequests) {
        await addMaintenanceRequest(buildingId, request);
      }
      
      print('‚úÖ Sample maintenance requests initialized for building $buildingId');
    } catch (e) {
      print('‚ùå Error initializing sample maintenance requests: $e');
    }
  }

  // Generate sample maintenance request data
  static List<MaintenanceRequest> _generateSampleMaintenanceRequests(String buildingId) {
    final now = DateTime.now();
    
    return [
      // Urgent elevator issue
      MaintenanceRequest(
        id: '',
        buildingId: buildingId,
        unitId: null, // Building-wide issue
        residentId: 'resident_1',
        title: '◊û◊¢◊ú◊ô◊™ ◊™◊ß◊ï◊¢◊î ◊ë◊ß◊ï◊û◊î 3',
        description: '◊î◊û◊¢◊ú◊ô◊™ ◊™◊ß◊ï◊¢◊î ◊ë◊ß◊ï◊û◊î ◊î◊©◊ú◊ô◊©◊ô◊™ ◊ï◊ú◊ê ◊û◊í◊ô◊ë◊î ◊ú◊ú◊ó◊ô◊¶◊ï◊™. ◊ì◊ó◊ï◊£!',
        category: MaintenanceCategory.elevator,
        priority: MaintenancePriority.urgent,
        status: MaintenanceStatus.assigned,
        assignedVendorId: 'vendor_elevator',
        assignedVendorName: '◊ó◊ë◊®◊™ ◊û◊¢◊ú◊ô◊ï◊™ ◊í◊ï◊ú◊ì◊ë◊®◊í',
        reportedAt: now.subtract(const Duration(hours: 2)),
        assignedAt: now.subtract(const Duration(hours: 1)),
        createdAt: now.subtract(const Duration(hours: 2)),
        updatedAt: now.subtract(const Duration(hours: 1)),
        location: '◊õ◊†◊ô◊°◊î ◊®◊ê◊©◊ô◊™ - ◊û◊¢◊ú◊ô◊™',
        estimatedCost: '‚Ç™1,500',
        isUrgent: true,
        requiresImmediateAttention: true,
      ),

      // High priority electrical issue
      MaintenanceRequest(
        id: '',
        buildingId: buildingId,
        unitId: null,
        residentId: 'resident_2',
        title: '◊™◊ê◊ï◊®◊î ◊õ◊ë◊ï◊ô◊î ◊ë◊ó◊†◊ô◊ï◊ü',
        description: '◊õ◊ú ◊î◊™◊ê◊ï◊®◊î ◊ë◊ó◊†◊ô◊ï◊ü ◊î◊™◊™-◊ß◊®◊ß◊¢◊ô ◊õ◊ë◊ï◊ô◊î. ◊û◊°◊ï◊õ◊ü ◊ú◊™◊†◊ï◊¢◊î.',
        category: MaintenanceCategory.electrical,
        priority: MaintenancePriority.high,
        status: MaintenanceStatus.inProgress,
        assignedVendorId: 'vendor_electric',
        assignedVendorName: '◊ó◊ë◊®◊™ ◊ó◊©◊û◊ú ◊õ◊î◊ü',
        reportedAt: now.subtract(const Duration(hours: 8)),
        assignedAt: now.subtract(const Duration(hours: 6)),
        startedAt: now.subtract(const Duration(hours: 2)),
        createdAt: now.subtract(const Duration(hours: 8)),
        updatedAt: now.subtract(const Duration(hours: 2)),
        location: '◊ó◊†◊ô◊ï◊ü ◊™◊™-◊ß◊®◊ß◊¢◊ô',
        estimatedCost: '‚Ç™800',
        photoUrls: ['https://example.com/garage_lights.jpg'],
      ),

      // Normal priority plumbing issue
      MaintenanceRequest(
        id: '',
        buildingId: buildingId,
        unitId: 'unit_5',
        residentId: 'resident_3',
        title: '◊ì◊ú◊ô◊§◊™ ◊û◊ô◊ù ◊ß◊ò◊†◊î',
        description: '◊ì◊ú◊ô◊§◊î ◊ß◊ò◊†◊î ◊û◊î◊ë◊®◊ñ ◊ë◊û◊ò◊ë◊ó. ◊ú◊ê ◊ì◊ó◊ï◊£ ◊ê◊ë◊ú ◊¶◊®◊ô◊ö ◊™◊ô◊ß◊ï◊ü.',
        category: MaintenanceCategory.plumbing,
        priority: MaintenancePriority.normal,
        status: MaintenanceStatus.pending,
        reportedAt: now.subtract(const Duration(days: 1)),
        createdAt: now.subtract(const Duration(days: 1)),
        updatedAt: now.subtract(const Duration(days: 1)),
        location: '◊ì◊ô◊®◊î 5 - ◊û◊ò◊ë◊ó',
        estimatedCost: '‚Ç™300',
        notes: '◊î◊ì◊ú◊ô◊§◊î ◊ß◊ò◊†◊î, ◊ê◊ë◊ú ◊û◊§◊®◊ô◊¢◊î',
      ),

      // Completed gardening work
      MaintenanceRequest(
        id: '',
        buildingId: buildingId,
        unitId: null,
        residentId: 'resident_4',
        title: '◊í◊ô◊ñ◊ï◊ù ◊¢◊¶◊ô◊ù ◊ë◊í◊ô◊†◊î',
        description: '◊î◊¢◊¶◊ô◊ù ◊ë◊í◊ô◊†◊î ◊¶◊®◊ô◊õ◊ô◊ù ◊í◊ô◊ñ◊ï◊ù, ◊ó◊ú◊ß◊ù ◊ó◊ï◊°◊û◊ô◊ù ◊ó◊ú◊ï◊†◊ï◊™.',
        category: MaintenanceCategory.gardening,
        priority: MaintenancePriority.normal,
        status: MaintenanceStatus.completed,
        assignedVendorId: 'vendor_garden',
        assignedVendorName: '◊í◊ô◊†◊ï◊ü ◊ô◊®◊ï◊ß',
        reportedAt: now.subtract(const Duration(days: 5)),
        assignedAt: now.subtract(const Duration(days: 4)),
        startedAt: now.subtract(const Duration(days: 3)),
        completedAt: now.subtract(const Duration(days: 2)),
        createdAt: now.subtract(const Duration(days: 5)),
        updatedAt: now.subtract(const Duration(days: 2)),
        location: '◊í◊ô◊†◊î ◊û◊®◊õ◊ñ◊ô◊™',
        estimatedCost: '‚Ç™1,200',
        actualCost: '‚Ç™1,000',
        notes: '◊î◊¢◊ë◊ï◊ì◊î ◊î◊ï◊©◊ú◊û◊î ◊ë◊î◊¶◊ú◊ó◊î, ◊î◊í◊ô◊†◊î ◊†◊®◊ê◊ô◊™ ◊û◊¢◊ï◊ú◊î',
      ),

      // Low priority cleaning request
      MaintenanceRequest(
        id: '',
        buildingId: buildingId,
        unitId: null,
        residentId: 'resident_5',
        title: '◊†◊ô◊ß◊ô◊ï◊ü ◊¢◊û◊ï◊ß ◊ú◊û◊ì◊®◊í◊ï◊™',
        description: '◊î◊û◊ì◊®◊í◊ï◊™ ◊ñ◊ß◊ï◊ß◊ï◊™ ◊ú◊†◊ô◊ß◊ô◊ï◊ü ◊¢◊û◊ï◊ß ◊ï◊ó◊ô◊ì◊ï◊© ◊î◊¶◊ô◊§◊ï◊ô.',
        category: MaintenanceCategory.cleaning,
        priority: MaintenancePriority.low,
        status: MaintenanceStatus.pending,
        reportedAt: now.subtract(const Duration(days: 3)),
        createdAt: now.subtract(const Duration(days: 3)),
        updatedAt: now.subtract(const Duration(days: 3)),
        location: '◊ë◊ô◊™ ◊û◊ì◊®◊í◊ï◊™ ◊®◊ê◊©◊ô',
        estimatedCost: '‚Ç™600',
        notes: '◊ú◊ê ◊ì◊ó◊ï◊£, ◊ê◊ë◊ú ◊ô◊§◊î ◊î◊ë◊†◊ô◊ô◊ü',
      ),

      // HVAC issue
      MaintenanceRequest(
        id: '',
        buildingId: buildingId,
        unitId: 'unit_8',
        residentId: 'resident_6',
        title: '◊û◊ñ◊í◊ü ◊ú◊ê ◊û◊ß◊®◊®',
        description: '◊î◊û◊ñ◊í◊ü ◊ë◊°◊ú◊ï◊ü ◊ú◊ê ◊û◊ß◊®◊® ◊õ◊®◊ê◊ï◊ô, ◊¶◊®◊ô◊ö ◊ë◊ì◊ô◊ß◊î.',
        category: MaintenanceCategory.hvac,
        priority: MaintenancePriority.high,
        status: MaintenanceStatus.assigned,
        assignedVendorId: 'vendor_hvac',
        assignedVendorName: '◊û◊ô◊ñ◊ï◊í ◊ê◊ï◊ï◊ô◊® ◊ß◊ú',
        reportedAt: now.subtract(const Duration(hours: 12)),
        assignedAt: now.subtract(const Duration(hours: 8)),
        createdAt: now.subtract(const Duration(hours: 12)),
        updatedAt: now.subtract(const Duration(hours: 8)),
        location: '◊ì◊ô◊®◊î 8 - ◊°◊ú◊ï◊ü',
        estimatedCost: '‚Ç™500',
      ),
    ];
  }

}